"""GraphWiz-XR code integrator for applying agent-generated changes."""

from pathlib import Path
from typing import Dict, Any, Optional
import logging


class GraphWizIntegrator:
    """Integrates agent-generated changes into GraphWiz-XR codebase."""

    def __init__(self, config: Dict[str, Any]):
        """Initialize integrator.

        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.project_path = Path(config.get("project_path", "."))

    def apply_changes(self, code: str, action: Dict[str, Any]) -> bool:
        """Apply code changes generated by the agent.

        Args:
            code: Generated code
            action: Action metadata (file, context, etc.)

        Returns:
            True if successful
        """
        try:
            file_path = action.get("file")
            if not file_path:
                self.logger.warning("No file specified in action, skipping code application")
                return False

            full_path = self.project_path / file_path

            # Create directory if needed
            full_path.parent.mkdir(parents=True, exist_ok=True)

            # Write code to file
            with open(full_path, "w") as f:
                f.write(code)

            self.logger.info(f"Applied changes to {file_path}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to apply changes: {e}")
            return False

    def modify_file(self, file_path: str, replacements: Dict[str, str]) -> bool:
        """Modify existing file with replacements.

        Args:
            file_path: Path to file (relative to project root)
            replacements: Dictionary of old_code -> new_code mappings

        Returns:
            True if successful
        """
        try:
            full_path = self.project_path / file_path

            if not full_path.exists():
                self.logger.error(f"File not found: {file_path}")
                return False

            with open(full_path) as f:
                content = f.read()

            # Apply replacements
            for old_code, new_code in replacements.items():
                if old_code in content:
                    content = content.replace(old_code, new_code)
                    self.logger.info(f"Applied replacement to {file_path}")
                else:
                    self.logger.warning(f"Pattern not found in {file_path}")

            # Write back
            with open(full_path, "w") as f:
                f.write(content)

            return True

        except Exception as e:
            self.logger.error(f"Failed to modify file: {e}")
            return False

    def validate_change(self, file_path: str) -> bool:
        """Validate that a change doesn't break compilation/tests.

        Args:
            file_path: Path to changed file

        Returns:
            True if validation passes
        """
        # Run basic syntax checks
        if file_path.endswith(".rs"):
            return self._validate_rust(file_path)
        elif file_path.endswith(".ts") or file_path.endswith(".tsx"):
            return self._validate_typescript(file_path)

        return True

    def _validate_rust(self, file_path: str) -> bool:
        """Validate Rust code."""
        try:
            import subprocess
            result = subprocess.run(
                ["cargo", "check", "--message-format=short"],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                timeout=60
            )
            return result.returncode == 0
        except Exception as e:
            self.logger.warning(f"Rust validation failed: {e}")
            return False

    def _validate_typescript(self, file_path: str) -> bool:
        """Validate TypeScript code."""
        try:
            import subprocess
            result = subprocess.run(
                ["pnpm", "exec", "tsc", "--noEmit", file_path],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                timeout=30
            )
            return result.returncode == 0
        except Exception as e:
            self.logger.warning(f"TypeScript validation failed: {e}")
            return False
